<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0058)http://members.aol.com/humansandt/papers/asgame/asgame.htm -->
<HTML><HEAD><TITLE>"Sw Devt as Cooperative Game" Talk</TITLE>
<META content="text/html; charset=windows-1252" http-equiv=Content-Type>
<META content="MSHTML 5.00.2614.3500" name=GENERATOR></HEAD>
<BODY>
<H1>Software Development as a Cooperative Game </H1>
<P><A href="http://members.aol.com/acockburn">Alistair Cockburn </A>Humans and 
Technology, 7691 Dell Rd, Salt Lake City, UT 84121 <BR><A 
href="mailto:arc@acm.org">arc@acm.org</A> 
<P><SMALL><I>(This is an html draft of HaT.tr.98.03, a talk first given at 
ObjectActive in South Africa, June, 1999. This file was converted from Word to 
Html by MS Word97, which I know makes Html mistakes. The html was auto-generated 
and hand-patched. Let me know if you find mistakes in 
it.)</I></SMALL><BR><I><SMALL>counter is</SMALL></I> <IMG alt=;-) 
src="Sw Devt as Cooperative Game Talk_files/counter.gif"> 
<H4><IMG align=right src="Sw Devt as Cooperative Game Talk_files/image44.gif"> 
</H4>
<P>My name is Alistair Cockburn - pronounced Co-burn,. In the U.S. they often 
forget to teach that 'ck' is occasionally silent, as in my name. 
<P>I am a hardware and software engineer by training, but my chosen profession 
is that of a methodologist. That means that I study how people produce software, 
successfully, or unsuccessfully. To most programmers, software methodologists, 
like software process designers and marketing people, are among the lowest of 
life forms, "scum", in the vernacular. To us, of course, we are essential agents 
of life, rather like blue-green algae. No doubt, to blue-green algae, other 
algae are attractive. But from a certain distance, and to a swimmer crossing the 
pond, they look mostly like scum. 
<P>I'm a methodologist, not a process designer. I have rather a distrust of most 
software proceses, as some of you will hav come to understand by now. I think 
most documented software processes are simply incorrect. But this is like saying 
I am really a blue algae, not a blue-green algae. To the swimmer, it makes no 
difference what color the scum is. 
<P>As a true-blue methodologist, I work by collecting raw data: A person says, 
"We did this. This happened." I take that as a fact. Collect facts like that. 
Then I look at cognitive science, neuro-linguistic programming, sociology, 
ethnography, organizational theory and personality types, looking for their 
theories of what is at work, what is cause and what is effect - what is the 
"ecology" that surrounds programming. They are not facts, but ideas I can build 
on and test against my facts and observations. I keep the ones that I like and 
seem to explain something. Then I make a wild guess at at theory that fits some 
of the data. 
<P>Then I try to break the theory. Well, actually, I don't really want to break 
it. I really want it to be right. So maybe I don't try all that hard to break 
it. I don't show it to my worst opponents, because they'll break it too easily. 
But I announce the theory, preferably in the middle of programmers or in the 
middle of a project, and see how people react. However much I want the theory to 
be correct, I have found that I only make progress when they break it. 
<P>What I have observed in the last 10 years of doing this, is that there is 
this cycle. I start off fairly ignorant and with a guess. I learn and learn, and 
then think I know something. I am at the top of this turning wheel. I announce 
and try my theory, and immediately start discovering it doesn't work. So my 
understanding starts dropping, until I end up convinced I know nothing and am 
totally depressed. At that point I notice something new or have an idea, and 
start collecting information again. 
<P>This wheel goes up, pauses, then comes down. I have been around that wheel 
approximately six times in the last 10 years, and have gotten to know the 
feeling. 
<P>I was giving a talk like this a cycle or so ago, and told all this to the 
audience. I said, "I have bad news for you. While preparing for this talk, I 
discovered that I am currently at the top of cycle. That means I can announce 
with perfect certainty and wonderful evidence what I believe, and be completely 
sure that it is wrong. However, I have no information as to where or how it is 
wrong. And what's worse, since I have been around the circle 4 times, I can 
probably tell you where you are wrong, but you can't tell me where I am wrong." 
With that, I began my lecture. 
<P>You are in a better position today. Since I discovered that cycle, preparing 
for that talk, I decided to try to start on the next cycle even while I was 
still going up on the current cycle. So I am going up and down simultaneously on 
different ideas. So now I can describe theories I know hasn't reached fruition 
yet, so I don't know where they are going, and in the next breath tell you stuff 
that used to be true and is now suspect. And I have so many stories to make or 
break any theory that is just dizzying. 
<P>An aside before I go on with the reassuring and comforting part of this talk, 
which is the theory I am currently trying to convince you to use. 
<P>It appears to me that software development is happening in industry, not in 
the universities. Universities are great for problems that can be solved by 
sitting alone and thinking or experimenting for months on end. Universities were 
great for giving us automata theory, complexity analysis, compilers and the 
like. But universities are not at all well suited to understanding what is 
happening during software development. 
<P>Software development -at the moment- is much more like early manufacture of 
samurai swords, shields, and battlefield tactics. You make a pile of swords or 
war tactics, send them onto the battlefield, and see which ones worked better. 
Then you make different swords and tactics, and so on. You can't figure out the 
right answer sitting alone in the room. You have to be on the battlefield. I 
can't imagine learning the things I've learned while sitting peacefully in my 
office reflecting. Most of my original reflections and predictions were just 
wrong. So any one of you who is interested in this topic probably has to work as 
a developer or consultant, so you can see the moment-to-moment action and get 
raw data. 
<P>I took part in a discussion up at the University a short while ago, to 
discuss the idea of a "Software Engineering" curriculum, as distinct from 
Computer Science. Not to poke fun of this particular Univ. - the department head 
is very sympathetic to the concept, and the representative from the Dean's 
office is a professor who is right in line with the common thinking in the 
academic segment of our industry. They were discussing "What People Would Think 
- How Other Academics Would React". The were looking for a comparison faculty 
for this new curriculum. They wanted it to be like Chemical Engineering. That is 
a good, macho discipline. Good science, good engineering, good success rate, 
good money. But Software Engineering isn't like Chemical Engineering, and they 
were aware of it. I got around to describing how software engineering research 
ought to be carried out - "rather like a social science, anthropology, for 
example". The Dean's representative snorted, "That's just what we don't need - 
to be contaminated with the status of a social science department!" 
<P>That struck me as rather odd, given the generally low opinion people have of 
the intellectual rigor of Computer Science as a discipline. Rather like the 
rocks on the bottom of the pond calling the mud "low". However, he didn't look 
to be in a particularly receptive mood at the time, so I didn't mention it to 
him. I did, however, think it. To me, as a blue algae scum, a social 
anthropologist is a collegial lower life form, perhaps a brown algae. Also life 
giving, and something to learn from. At least sitting out in the field, learning 
how the big world works. 
<P>Anyway, here I am, true-blue algae though I might be, and trying to tell you 
my best current guess as to how this software development thing works. All of 
what I have to say is based on facts, backed by guessing and checking. Or 
guessing around facts and checks. 
<P>You will notice that my talk doesn't follow the published slides in the 
proceedings. The reason for this is that I have had both inspiration and 
breakage since I sent in the slides. Derek can tell you how hard it was to get 
slides from me in time to publish - and I hated to send them, even then. I am 
always convinced I'll learn something critical and damaging the day before the 
talk, so my preferred mode of operation is to write the talk from 11 pm to 4 am 
the night before the talk. But in this case, Derek prevailed. The talk slides 
are almost a month old, so of course I have found a new way to talk the material 
by now. 
<P>I'll try to put this all into the smallest number of words and let those of 
you who get it right away get it right away. I believe these ideas are correct 
and will stand you in good stead on your current and next projects. 
<H3>------------ 1. Communication </H3>
<P><IMG align=right 
src="Sw Devt as Cooperative Game Talk_files/image45.gif"><U>The first thing to 
get is that no communication is ever perfect and complete</U>. 
<P>It just can't be done. It is not even in the realm of possibility. Your 
listener, or the receiver of the communication, has to jump across a gap, at 
some point, and has to do that all on their own. You can't do it for them. If 
they are very different from you, then they can't jump a big gap. You have to 
explain some basic concepts to them, and then build forward until they build 
their own bridge of experience so they can finally get what you are saying. But 
however much you back up, there is someone who wouldn't understand that, and 
you'd have to back up more. There is no final end point to this backing up. 
However, if you are communicating with someone who has a very similar 
background, you wave your hands and mutter a few phrases, and they get it. They 
can jump a huge distance, because they have a similar base of experience to draw 
from, and can fill the gap with accurate predictions of your meanings. 
<P>The way I say all of that in shortest form is, "All communication is touching 
into shared experience." 
<P>The point is, we write these specification and design documents <I>as 
though</I> we could actually ever explain what we mean. And we can't. We can 
never hope to completely specify the requirements or the design. Not even the 
faintest chance. When we write, we assume that the reader has a certain level of 
experience. If we can assume more experience, then we can write less. If we have 
to assume less experience, then we have to write more. 
<P>I was working with a US company that was employing programmers in Russia. 
They wanted me to teach them to write use cases in the US for programmers who 
knew neither English nor the domain. I said, "You can't hope to teach them the 
domain inside the requirements document. First teach them the domain, then write 
a short requirements document that speaks to someone knowledgeable in the 
domain." They decided to do one better. They decided to write the short version 
of the requirements document, and then fly one of their domain experts over to 
Russia for 2 weeks at a time to translate, explain and generally ensure that the 
programmers were doing the right thing. 
<P>See how that works? The domain specialist could jump the large gap presented 
by the brief use case document, and then back up, <I>as needed, and only as 
needed</I>, to fill in to get the size of gaps that the Russian programmers 
could jump. 
<P>So the first signifant idea I have to give you today is that complete 
communication is never possible, and so it is our task in on a software 
development project <I>to manage the incompleteness of our communications</I>. 
Estimate how much is needed, when we can quit, how we can help receivers to jump 
larger gaps, when and how to make the gaps smaller. Every time we try to make 
the gap smaller, it costs time and money, and software projects are short on 
both. So what we want is to find out how large of a gap - how much 
incompleteness in the communication - we can get away with, and stop there. 
<P><IMG align=right 
src="Sw Devt as Cooperative Game Talk_files/image46.gif">There is a second moral 
to that story. How did the company decide to fill in the programmers' gaps? By 
making them read books? Sending them to a course (that's what I suggested). No, 
by sending someone to talk with them, <I>face to face</I>. Because real-time, 
multi-modal, 3dimensional, face-to-face communcation with question and answer is 
the most effective way to transfer information and see that it was received. Two 
people standing at the white board, talking, questioning, drawing, maybe typing 
on the computer if that is the issue. 
<H3>------------- 2. Using Whiteboards </H3>
<P><U></U>
<P>So the second idea of the day is that as you remove those characteristics of 
two people at the whiteboard, you reduce the efficiency and effectiveness of the 
communication session. 
<P>That is what the graph shows. Take away part proximity, and you get video 
conferencing, and many of us have experienced how hard it is to collaborate over 
a video link. You lose 3dimensionality, the visual proximity that gives 
non-verbal cues. Back up one step further, put people on the phone and you lose 
all visual cues. Go to email and you lose tonal inflection, and timing. Go to 
videotape to get visuals back but lose question-and-answer. Go to audiotape and 
lose visuals again. 
<P>Go to paper and guess what? You've lost almost everything. The writer has to, 
very laboriously, I should note, guess who the audience is, guess their level of 
experience, guess what they understand, guess what their questions will be, and 
guess what the best answers to those questions are. What are the odds of them 
getting all that right? Very small. And expensive. 
<P>But how do we demand that people communicate on a project? Written text and 
drawings! In the light of this communications model, that is clearly absurb - 
and yet we do it. We demand that people communicate in the slowest, least 
effective medium, and downplay the most effective medium. 
<P>So if this theory is any good, we should be able to draw a prediction from 
it. All right, here is the prediction I get from looking at this graph. How 
should we create archival documentation of a design decision? Back up the curve 
to highest archivable communication medium, and we find Videotape. 
<P>This suggests the following documentation scenario. The designer gives a 
10-20 minute, semi-prepared talk at the whiteboard, telling some other 
designers, who do not know the answer, how the system works. They get to ask 
questions. The designer will first fill in background details, give the simple 
solution, then add complexity. The questions will indicate where the designer 
has been vague, and the designer will explain. All this is videotaped. After the 
taping, someone transfers a couple of the key drawings, instances diagrams, 
collaboration diagrams, examples, whatever, to paper, so that the people can 
<I>recall from looking at the drawings</I>, what the conversation was. And, 
finally, someone puts index marks on the videotape for <I>where interesting bits 
of the discussion took place</I>, and publishes that index along with the draw. 
People can then review the drawings, recall the conversation, and look up the 
key discussion on the tape. All this would be relatively inexpensive and easy to 
to do. Certainly faster and more palatable to the person having to do the 
presentation, and plausibly more informative to the viewer. 
<P>I've been trying to find people who have done this or who are willing to try 
this out. So far, I have found that Gerald Weinberg made a similar suggestion a 
decade ago, by whatever reasoning he got to it. I found a woman at Lucent 
Technologies / Bell Labs who had actually done this once and said it worked 
great. Actually, she was the one who told me to put the index marks on the video 
tape and publish them. Recently, I have found a team lead over several projects 
who said he will try this sometime soon. So hopefully I'll get back more than 
just the one answer as to whether this model gives good predictions. If any of 
you are willing to try this, please let me know: what you did, and what 
happened. 
<P>The upshot of this model is the conclusion that you want to encourage 
informal, face-to-face contact wherever possible. In fact, you want to 
<I>rely</I> on it. It should not be an accident, it should be core to your 
development process. Put the people in one room, if possible, in adjacent 
offices at least. Jim Coplien says that studiies show that as soon as people 
have to cross a stairwell, communication drops precipitously. 
<H3>----------3. People are Active Devices </H3>
<P><U></U>
<P>This gets us to the third signifant idea: that software development processes 
use humans as the active components. 
<P>Humans are not linear devices, the way rods and hinges are. Even non-linear 
devices like transistors are easy to characterize compared with people. So when 
we talk about the software development process, we should first try to find out 
what are the active characteristics of these things called "people". 
<P>People have lots of interesting characteristics, and we don't know what they 
are - which makes it all the more absurd that we try to define methodologies and 
processes that incorporate them. 
<P>People are really good at just looking around, around the code, around the 
project, around the problem, and understanding what's going on. So you don't 
have to be all that precise, in many instances, you rely on people being able to 
look around. Program maintainers tell me this all the time. They expect the 
documentation to be out of date, so they just go and read the code. 
<P>People are really good at communicating with other people, face to face, of 
course. 
<P>People are really good at taking initiative, just seeing what needs to be 
done, and doing it. It is my experience that this is what saves most processes - 
people do whatever is needed, never mind what the process says. In my interviews 
with projects, when I ask how the project managed to deliver in the end, there 
is almost always some comment about "a few good people, who stepped in and just 
did whatever was necessary." 
<P>However, people are typically inconsistent in their work, careless, sloppy 
and undisciplined. You can pretty much count on it. They don't read the 
instructions. They goof off alternating with working hard. They resist learning 
and using new ideas. All of those make life hard on the process designer. 
Whatever the actual optimal process and design technique could manage to be, 
people will resist using it, and then use it sporadically and carelessly, and 
then have to step in with some personal heroics to make it all work out in the 
end. 
<P>This curse plagues all of us blue and blue-green algae - it doesn't matter 
what great estimating, designing, programming, testing, managing techniques we 
discover and teach, people generally won't use them anyway. 
<P>So these are some of the characteristics of people - their success modes, and 
their failure modes. I am trying to build my newest set of methodologies around 
them. Around apprenticeship programs, because that allows learning by example, 
on the job, in personal contact with another, with feedback. All these are 
important, and I'll get back to some of them as we go along here. 
<P><IMG align=right src="Sw Devt as Cooperative Game Talk_files/image47.gif">One 
of the most interesting discoveries I made while capturing one group's 
methodology, was this milestone I call a "Declaration" milestone. I found 3 
kinds of milestones, and have found them since on all projects. The first is one 
we expect: a Review. A review happens when a number of people congregate and 
stare at some work product and give feedback. The interesting questions about a 
review are "Who is there?", "What are they staring at?" and "What does it mean 
to Fail the review?" 
<P>The second kind of milestone is "Publish". Every time you check code back 
into the configuration management system that is a form of publish. Other 
Publish milestones involve deploying the software, circulating a document, and 
the like. These are also fairly obvious. 
<P>"Declaration" is, however, not obvious.. When does the technical writing 
group start writing the online help text? The answer I found was that the team 
lead would show up and say, "It's ready". The team lead doesn't mean, "It's 
complete, correct, done, defect free" or any of those things. The team lead 
simply means, "If you start writing now, I believer that the further changes we 
will make will be small compared to the total effort of writing." (In my book, 
in the Risk Reduction Strategies section, there is a strategy called Gold Rush 
that discusses this sort of activity). 
<P>There is no double-check on the correctness of the team lead's assertion. It 
just is "declared". Since that time, I have found many examples of the 
Declaration milestone that are used in project scheduling. "The object model is 
stable enough for the DBAs to start designing from" is one. "Our software is 
ready for Alpha Release." Alpha release? When is the software ready for Alpha 
Release? When it is bug-free? Of course not! When what? When someone decides 
that the defect state is low enough that the alpha users can tolerate it. It is 
simply a Declaration. Declaration milestones are an example of the way we manage 
the incompletenes of communication. 
<P> 
<H3>--------------- 4. Games </H3>
<P><U></U>
<P>At this point I'm going to jump to the most powerful predictor I have come 
across for managing software development - considering it as a cooperative game. 

<P>Games are not just what children play, although those are also games. Games 
are invented by adults, by mathematicians, by novelists, by teenagers, and by 
children. 
<P>If you are sitting around the living room on a winter's evening, and someone 
says, "Let's play a game," what could you play? You could play charades 
(play-acting to uncover a hidden phrase). You could play tic-tac-toe or 
checkers, poker or bridge. You could play hide-and-seek or table tennis. You 
could play "when I took a trip...", a game in which each person adds a sentence 
onto a story that grows in the telling. You could end up having a wrestling 
match on the living room floor. 
<P>Checkers and tic-tac-toe are <I>positional</I> <I>games</I>. The entire state 
of the game at any moment is represented by the position on the board at that 
moment. These games have properties that mathematicians find interesting, and 
John Conway, in the book <U>On Numbers and Games</U>, shows how 2-person, 
positional games can be used to define all numbers, real, imaginary, finite or 
transfinite. He actually generates the notion of number from the notion of 
2-person, positional games. 
<P>Most competitive games, such as checkers, tic-tac-toe, bridge and table 
tennis, are <I>zero</I>-<I>sum</I> games. Two sides play, one side wins, one 
side loses. If you score 1 point for winning, and -1 point for losing, at the 
end of the game the sum of the scores is zero. "Not everyone wins," is a fact 
not lost on adults creating games for children's parties. 
<P>Many of the games you would consider playing on that winter's evening are not 
zero-sum games. In poker, gin rummy, parchesi and other group competitive games, 
only one person wins, the rest lose. In hide-and-seek, any number of the hiders 
may win (or lose) against the seeker. 
<P>But rock climbing, story-telling, and carpet wrestling are not about winning 
or losing; the game is all about having fun. As long as the guessing or the 
story-telling is interesting, the game is worth playing. These are 
<I>cooperative</I> games. The point of the game is to interact with each other, 
or perhaps to help each other. 
<P>Not all games even have an end! The story-telling game, the carpet-wrestling, 
and the musical session are not even <I>goal-seeking </I>games. It is not the 
purpose to reach a goal as fast as possible. They come to an end when enough 
people get tired of playing and step out. The game is expected to end, but has 
not particular endpoint. 
<P>There are, however, some games in which the primary intention is to NOT end - 
to keep the game going. These are called <I>infinite</I> games (all the other 
games must therefore be <I>finite</I>). If you start a club or a company, the 
purpose is to keep the club or company going. The way to keep the club going is 
to make it interesting for the participants. A person's profession falls into 
the category of an infinite game. The person, wanting to to continue the 
profession, makes a set of moves which permit their practice of that profession 
to continue. 
<P><IMG align=right src="Sw Devt as Cooperative Game Talk_files/image57.gif">So 
games come in all sorts of flavors. We have seen just a few possible dimensions: 
physical / mental / solo / team-based / competitive / cooperative / goal-seeking 
/ finite / infinite.. It is therefore appropriate that the American Heritage 
Dictionary gives the first definition of game as: "A way amusing oneself." 
<P>Getting slowly to software development, I'll briefly consider rock climbing. 
In contrast with children playing Legos or jazz musicians jamming, climbers aim 
to reach the top. They evaluate the climb on how well they climbed together, and 
how much they enjoyed themselves, but the first measure of success is whether 
they reached the top. Reaching the endpoint is a primary goal, and the game is 
over when they reach the top. So rock-climbing is a goal-seeking, cooperative 
game. 
<P>Now if you are a rock climber, you might well interrupt me here. For many 
rock climbers, the moment of reaching the end of the climb is a sad one, for it 
signals the end of the game. That is true of cooperative games in general. The 
game comes to an end when the endpoint is reached, but if the players have been 
enjoying themselves, they may not want to stop. When we compare to software 
development, we do indeed see that sometimes software developers do not want to 
finish their design, because then the fun part of their work will be over. 
Software development is similar to rock-climbing in ways that I shall develop a 
little more fully in a minute. 
<P><IMG align=right src="Sw Devt as Cooperative Game Talk_files/image49.gif">I 
would like you to consider software development as a <I>cooperative</I>, 
<I>finite</I>, <I>goal-seeking,</I> <I>group</I> game. The goal is to produce a 
working system. The group, or team, consists of the sponsor, manager, 
requirements or usage specialists, software designers, testers, and writers. 
Usually the goal is to produce the system as quickly as possible, but there 
other factors affect the time goal: ease of use, cost, defect freedom, and 
liability protection. In general, it is a resource-limited game, which affects 
how the moves are made. 
<P>The game is finite because it is officially over when the goal is reached. 
Sometimes the termination point is delivery of the system, sometimes it comes a 
bit later. But funding and motivation for the game change around the time the 
system is delivered, and a new game is defined. The new game may be to improve 
the system, to replace the system, to build an entirely different system, or 
possibly, to disband the group. 
<P>The game is cooperative because the people on the team help each other to 
reach the goal. The measure of their quality as a team is how well they 
cooperate and communicate during the game. This measure is used because that 
affects how well they reach the goal. 
<P>Although the software development game within the project is finite and 
cooperative, other games are being played at the same time, other games, with 
other characteristics. 
<P>Software development is <I>competitive</I> across teams. Teams in different 
companies - sometimes within the same company- compete to put the system out 
ahead of the other teams. The competitive game across teams is in play at the 
same time at the same time as each team is working its cooperative game (think 
here of team rock-climbing competitions). 
<P>Career management is an <I>infinite</I> game for the individual. The purpose 
of playing this game well is to be able to get the best position on the next 
game. As with the card game called "So long, sucker", the teams and alliances in 
and individual's career management change continually and without notice. The 
individual moves people make for their career affect the ways in which they 
collaborate with their alleged teammates. 
<P>Organizational survival is an <I>infinite</I> <I>group</I> game. It is 
cooperative within the organization (subject to the individual career game), and 
competitive across organizations. 
<P>This <I>game</I> model of software development has stood me in good stead 
recently, as I evaluate military software projects and open-source software 
development. In some of the military software projects, what we see is 
predominance of the career- and corporate-enhancing infinite games. It is quite 
clear that delivery of the software is a secondary concern, and growing the 
company, growing personal influence, or growing the career is what is many 
people's minds. The logic of the funny contractor behavior doesn't make sense 
until you realize they are playing a different game, in which different moves 
are called for. Then it suddenly all makes sense - even if you don't like it. 
<P>Open-source development is different because it is not a resource-limited 
game, nor is it finite and end-point directed. Linus Torvald did not say, "We'll 
make a shippable copy of Linux, and then we can all go home." No, Linus is 
around, and it will evolve. The game is interesting as long as it is 
interesting. Any number of players may show up, and they are not on a time-line. 
The game will abandoned as soon as it stops being interesting for the players. 
In that sense, it is much more like musicians playing together, or 
carpet-wrestling, or lego building. It is a <I>cooperative game</I> that is not 
directed toward "reaching the goal", and is not built around managing scant 
resources. And so the moves that make sense in open-source development naturally 
don't make the same sense for a standard resource-limited, goal-seeking software 
development project. 
<P><IMG align=right src="Sw Devt as Cooperative Game Talk_files/image50.gif">Of 
all the comparison partners for software development that I have seen, rock 
climbing has emerged as the best. Here are some of the words and phrases that we 
can link with rock climbing. You can see how well they transfer to software 
development (by the way, read Jim Highsmith's new book, <U>Adaptive Software 
Development</U> for a more detailed look of the rock climbing comparison). 
<P><I></I>
<P>Rock climbing is Technical. The rock climber must have technical proficiency. 
The novice can only approach simple climbs. With practice, the climber can 
attack more and more difficult climbs. The better rock climber can simply do 
things that the others cannot. Similarly, software development is technical and 
requires technical proficiency, and there is a frank difference in what a more 
skilled person can do compared with a less skilled person. 
<P><I></I>
<P>Training. Rock climbers are continually training and searching for new 
techniques they can use, just as software designers do. 
<P><I></I>
<P>Technical Pass/Fail. A key point of comparison between rock climbing and 
software development, for me, is that not just any solution will do. The 
climbers must actually support their weight on their hand and feet; the software 
must actually run and produce reasonably accurate answers. This key 
characteristic is missing from most alternative activities that people select to 
compare software development with. 
<P><I></I>
<P>Individual and Team. Some people just naturally climb better than others. 
Some people will never handle certain climbs. At each moment on the climb, the 
person is drawing on their own capabilities, have to hold up their own weight. 
The same is true in software. 
<P>And yet, climbing is usually done in teams. There are a solo climbers, but 
they are in the minority. Under normal circumstances, climbers form a team for 
the purpose of a climb and the team has to actually work together to accomplish 
the climb. Similarly, software developers, while working on their individual 
assignments, must function as a team to get the software out. The "Team - 
Individual" dual aspects of software development form the basis for most of my 
current work in methodologies, and I'll get back to it before I'm done. 
<P><I></I>
<P>Tools. Tools are a requirement for serious rock-climbing: chalk, chucks, 
harness, rope, caribeener, and so on. It is important to be able to reach for 
the right tool for the right moment. It is possible to climb very small 
distances with no tools. The longer the climb, the more critical the tool 
selection is. You software developers will recognize this. When you need a 
performance profiler, you really need it. You can't funtion without the 
compiler. The team gets stuck without the version control system. And so on. 
<P><I></I>
<P>Planning and Improvising. Whether bouldering, doing a single-rope climb, or a 
multi-day climb, the climbers always make some sort of a plan. The longer the 
climb, the more extensive the plan must be, even though the team knows that the 
plan will be insufficient, and wrong in places. 
<P>Unforeseen, unforeseeable and purely chance obstacles are certain to show up 
on even the most meticulously planned climbing expeditions, unless the climb is 
short and the people have already done it several times before. Therefore, the 
climbers must be prepared to change their plans, to improvise, at a moment's 
notice. 
<P>This dichotomy is part of what makes software development manages gnash their 
teeth. They want a plan, but have to deal with unforeseen difficulties. It is 
one of the reasons why incremental development is so critical to project 
success. (Does that sound like climbing in stages, and setting various base 
camps?) 
<P><I></I>
<P>Fun. Climbers climb because it is fun. Climbers experience a sense of 
<I>flow</I> while climbing, and this total occupation is part of what makes it 
fun. Similarly, programmers typically enjoy their work, and part of that 
enjoyment is getting into the flow of designing or programming. Flow in the case 
of rock climbing is both physical and mental. Flow in the case of programming is 
purely mental. 
<P><I></I>
<P>Challenging. Climbers climb because there is a challenge - can they really 
make it to the top? Most programmers crave this challenge, too. If programmers 
do not find their assignment challenging, they may quit, or start embellishing 
the system with design elements they find challenging. 
<P><I></I>
<P>Resource-limited. Rock climbing works against a time and energy budget, 
needing to be completed before the team is too tired, before the food runs out, 
by nightfall or before the snows come. In general, climbers plan their climbs to 
fit a resource budget. Similarly, commercial software development is governed by 
budget and need. It is in this sense that open-source development is different 
from commercial software development. 
<P><I></I>
<P>Dangerous. If you fall wrong on a rock climb, you can die or get maimed. This 
is probably the one aspect of rock climbing that does not transfer to software 
development. Rock climbers are fond of saying that climbing with proper care is 
less dangerous than driving a car. However, I have never heard programmers need 
to even compare the danger of programming with the danger of driving a car or 
crossing the street. 
<P><IMG align=right 
src="Sw Devt as Cooperative Game Talk_files/image51.gif">Software development 
has been compared with math, science, engineering, poetry, theatre and jazz. It 
is useful to have such a comparison partner, because we can get some distance 
and clarity by comparing software development to its partner, and reflecting on 
whether that comparison holds in each particular case. I find rock climbing has 
more in common with software development than do all the comparison partners 
that have been used before. 
<P>Math, science and poetry are not games of same sort. Theatre is a finite, 
group, cooperative, planned/improvised game, but is not goal-seeking, and is 
missing the technical pass/fail nature of software and rock climbing. We could 
simply put on a terribly play and get away with it, if everything falls apart, 
but we cannot simply float up the rock climb or wish the software would run if 
it will not. 
<P>Engineering is too close to software development for us to stand outside of. 
In fact, I could be talking about engineering rather than software development 
here - it just happens to be about software. 
<P>There are two things that software development is not. <B>Science </B>is one 
of them. Of course, there has been much written as to just "what is" science, 
and I shall not try to recap it all here. However, there are several thoughts 
that can be usefully be considered for a moment. 
<P>The scientific method is oftan claimed to consist of "Observe, deduce, 
experiment, confirm." This adage has been discredited for a long time. Many 
science writers have shown that scientists very often start with an answer or 
hypothesis in mind, and set out to prove it. We should not encourage software to 
be developed using this adage, because it does not fit the matter of developing 
software, and it does not describe science in the first place 
<P>A closer phrasing is "Observe, <I>invent</I>, experiment, confirm." Where 
does the hypothesis come from? Invention. Sometimes invention after observation, 
sometimes invention on the basis of prior thinking on any number of topics. 
Having once invented an idea, a scientist quite often then sets out to 
demonstrate that the hypothesis is correct. This is also closer how many ideas 
reach fruition in software development. The designer observes, thinks, and 
invents some design. Sketches, prototypes and experiments are made to see if the 
idea "holds water", and if so, then it proceeds. 
<P>While a more accurate phrase, it does not give us insights as to how to 
manage the development of software, as it does not cover more than a small part 
of the software development process. It does not say anything about 
requirements, implementation, testing, deployment, teams, tools or training, in 
particular. 
<P>Paul Feyerabend [<U>Against Method</U>] claimed that scientific progress has 
been so different, from case to case, that no method could be said to work for 
it. Here at last we have a partner to software development! Starting from Peter 
Naur in the 1960s, we hear programmers and designers defending software 
development as a unique and individual activity, one that cannot be scheduled, 
predicted or turned into a procedure. However, this thought applies only to the 
inventive part of software development. While a significant part, it is not all 
of software development. My goal is to be able to say something constructive 
about managing software projects, even if we accept Paur Feyerabend and Peter 
Naur's thesis that there is no sure-fire, successful method for coming up with 
the invention. 
<P>Science is one thing that does not capture the essence of software 
development, and <B>Model building </B>is the other thing I wish to say that 
software development is not. Ivar Jacobson has actively promoted the view that 
"software development is model building", over the last decade, and it has ended 
up as a catch-phrase in the the industry. It is, however, dangerously 
inaccurate. 
<P>When software development becomes model building, then a valid measure of the 
quality of the software or of the development process is the quality of the 
models, their fidelity to the real-world, their completeness. However, as I 
interviewed dozens of successful projects around the world, I was repeatedly 
told that the people on the project did not have the time to complete their 
models, or never drew them at all. Their common comments were: 
<P>"We don't have time to create fancy or complete models. Often, we don't have 
time to create models at all." 
<P>or 
<P>"The interesting part of what we want to express doesn't get captured in 
those models. The interesting part is what we say to each other while drawing on 
the board." 
<P>In the cases where I have found people diligently creating models, software 
was not getting delivered. In other words, paying attention to the "models" 
interfered with developing the software. 
<P>How can we reconcile these interviews and many people's personal experiences 
with what is, no doubt, Ivar's voice of experience? The game description gives 
us an answer. 
<P>The game is to deliver the software. Any other activity is secondary. A 
model, or, indeed, any communication, is <I>sufficient,</I> <I>as soon as</I> it 
permits the next person to make their next move. The work products of the team, 
therefore, should be measured for <I>their sufficiency with respect to 
communicating to their target group</I> 
<P>They should be measured for nothing else. It does not matter if the model is 
incomplete, drawn with incorrect syntax, and actually not like the real world - 
if it communicates sufficiently to its recipient. In some cases, people get the 
intended communication from surprisingly sparse messages . In other cases, a 
more detailed, accurate communication is required,. Understanding the nature of 
the game, the rules and variations on the game, gives us insight into how 
elaborate a model to build, or whether to build a model at all. 
<P>Software development is a game of invention and communication. Communication 
is so important, that we need to spend time absorbing the range of factors that 
affect the quality of the communication. 
<P>This reference to communication gets us back to my opening section about 
communication as never being perfect and complete, communication as touching 
into shared experience. 
<P>I'll give you an example of how I use this two-legged model of software 
development as a goal-seeking game of invention and communication, and 
communication as touching into shared experience, never fully complete or 
perfect. 
<P>A project architect was telling me that sometimes a group of designers go to 
lunch, have an idea, and someone sketches out a design on a napkin. They go back 
and stick the napkin on their corkboard. For the next months, possibly longer, 
that napkin acts as the central touchpoint of the design - it is what people 
remember and point to when discussing the evolution of the design. 
<P>From my point of view, this is fine, and not merely fine, but very good. The 
napkin serves as a reminder. Because it is a napkin, the designers remember the 
restaurant, the room, the discussion. It has life in several sensory modes. It 
has shape, it has texture, it has, perhaps, grease stains. All of those anchor 
the memory of the discussion. 
<P>The architect was telling me that he had just hired a communications 
specialist. One of his ideas was that this communications specialist would walk 
around, and copy the contents of the napkin into some drawing tools so it would 
be pretty and archived for later reference. 
<P>In our discussion, we decided that copying that napkin into a drawing tool 
would cause it to <I>lose</I> information! The shape and texture of the napkin 
would be lost, the rectangles would be perfect instead of wobbly and different 
sizes. The memories associated with the napkin would be lost in the transfer. 
<P>But what alternative is there? Does the napkin just stay on the cork board - 
or is there some way to share it with the team? The answer was to scan the 
napkin into the computer, and put the scanned image into Lotus Notes or a Word 
file or whatever. Then the napkin itself becomes a design marker, complete with 
its bumpy texture and hand-drawn boxes. It is both cheaper and more informative 
than the redrawn version in the drawing tool. It fits both the communication 
model and the game model better. It is simply better for our purposes. 
<P>This was true on another project. A person came in and said, "Alistair, I 
know this is not a legitimate drawing in any known notation, but it is the best 
I can come up with." And he presented a hand drawing of stick figures doing what 
would more or less be called a work-flow or collaboration diagram. Over the 
months, my colleagues and I tried redrawing his drawing in any number of 
different forms, but whenever we had difficulties, we went back to his original 
drawing, which we had photocopied and distributed, because it communicated to us 
in ways no other drawing did. 
<H3>---------- 5. Methodology per project </H3>
<P><IMG align=right 
src="Sw Devt as Cooperative Game Talk_files/image52.gif"><U>The fifth point I'd 
like to make is that all projects are different, and so you need a different 
methodology on each project.</U> 
<P>First, I have say, what do I mean by "methodology". This is a repeat for 
those of you who came to my methodology tutorial. 
<P>Methodology, in the biggest sense of the word, is how your organization 
operates to deliver software, successfully, over and over again. Your 
methodology is your organization's strategy for winning the game. 
<P>"Big-M" methodology is what gets your software out. It is a unique 
construction of your organization - it is, in fact, a social agreement within 
the organization. It is 
<P>who you hire and what you hire them for, 
<P>how they work together, 
<P>what they each produce, 
<P>how they share. 
<P>It is the combined job descriptions, procedures and conventions of everyone 
on your team. 
<P>All organizations have a big-M methodology. It is simply how they do 
business. Even just seven people in a group have a way of working, a way of 
trading information, separating work into pieces suited to different people, of 
putting their work back together as the final product. All founded on assumed 
values and cultural "norms". 
<P>Only a few companies bother to try to write it all down, usually the large 
consulting houses: Andersen, Coopers &amp; Lybrand, Ernst &amp; Young, and so 
on. A few have gone so far as to create an expert system that prints out the 
full methodology needed for a project based on project staffing, complexity, 
deadlines and the like. No methodology I have seen captures the cultural 
assumptions or provides for variations along the lines of values or cultures. 
<P>The slide shows the basic elements of a "Big-M" methodology, with examples of 
some of those elements. The elements are teams, roles, skills, activities, 
techniques, tools, quality measures, deliverables, and standards - and team 
values. The diagram is as applicable to the poetry writing group as for a group 
of software developers. What gets filled behind each box varies, but the 
existence of the boxes doesn't. 
<P>A big-M methodology is 1/3 a matter of individual people doing their 
individual work, 2/3 thirds their working together, and a few percentage points 
of technology. Average people produce only average designs. However, all the 
smartest people together will not produce group success without cooperation, 
communication and coordination. Most of use have seen or heard of such groups. 
It would happen as well on a poetry or theatre project as on a software project. 
So success hinges around cooperation, communication and coordination, which, 
hinge around the <I>value systems</I> of the people in your organization. These 
value systems include 
<P>What people choose to spend their time on 
<P>How they choose to communicate 
<P>How decision-making power is distributed. 
<P><IMG align=right src="Sw Devt as Cooperative Game Talk_files/image53.gif">A 
set of factors make every software project different. One set revolves around 
the cultures of the nation, the organization, and the people. Another set 
revolves around the size of the project team, the number of people who need to 
coordinate their work. Another is the technical nature of the work, and 
alongside that is how life-critical the system is. Each variation of these will 
indicate the use of a slight variation in the methodology. Jim Highsmith refers 
to these as variations of the "fitness landscape". 
<P>So it is not the case at all that one methodology definition could possibly 
suit all projects. Don't even think that the Rational Unified Process, or the 
UML Unified Process, or the something something something methodology will fit 
your project out of the box. In fact, your first guess at the methodology to use 
on your project will be the worst guess you make, because it is based on no 
experience with the actual project. Over <I>the course of the project, you will 
be able to say much better what the most suitable methodology is</I>. But I'll 
get back to that in a minute. 
<P>For the moment, let's just consider two of the factors that characterize your 
project: the number of people, and how life-critical it is. That's what you see 
on the grid. I'd like you to consider that a 200-person project for an atomic 
power plant should really work in a different way than a 30-person Y2K project 
for a company, should really work in a different way than a 2-person project to 
keep scores for the neighborhood soccer league. They are just so different that 
it would seem strange to try to legislate one methodology for all three of them. 

<P>And yet, that's what we find. Organizations ask for the One True Methodology 
for their projects, COBOL and Java and mainframe and internetworked and mission 
critical and casual and large and small. It just doesn't make sense, and I'd 
like you all to be conscious of that. And authors publishing the One True 
Methodology, for all of the above. 
<P>These days, we find tailorable methodologies on the market, but most of them 
are not set up to handle the range of projects you see on the grid. And they 
don't say what their range of applicability is, so you can't tell just from 
reading the cover notes. 
<P>So the next idea I'd like you consider is that every category of project on 
the grid plausibly has its own, most suited methodology. Further, that within 
each grid box, each project will have its own slightly different optimal 
methodology, based on the cultures, the expertise, the strengths and the 
weaknesses of the people involved. 
<P>That means, that your first guess at the methodology to use on your project 
will be the worst guess. This plays in with our discussion of software 
development as a game, and the characteristics of people as active devices. One 
of the characteristics of people is that they learn from feedback - from seeing 
results. They learn how to develop software through incremental development, and 
the sooner the feedback the better. 
<P>The punchline of this particular line of thinking is that you will look at 
the external characteristics of your project - based upon this grid, among other 
things - and nominate your best guess at a methodology. In some sense, it really 
does not matter what you nominate, although I can suggest that the lightest 
methodology you can imagine getting away with will probably do you the most good 
as a starting guess. 
<P>Then you make sure you work in increments... no longer than 4 months for any 
one increment, preferably shorter. Good people are telling me these days that 
they distrust increments longer than 2 months, but I am still comfortable with 
increments of 3-4months duration. So make sure you exercise the entire process 
every 4 months or sooner - every team delivers some piece of running, tested 
code every 4 months or sooner. 
<P>And at the end of each increment - at the start of each increment, if you 
like - you ask the following questions: 
<P>-what did we do right? what did we do wrong? 
<P>-what are our priorities 
<P>- what is it most important that we keep? 
<P>-what do we change for next time? 
<P>-what do we have to add? what can we drop? 
<P>After 2 or 3 increments, you will start to converge on a methodology that 
your project can tolerate, even thrive on. 
<P>As you can see, this strategy will not even make sense unless you are 
developing in increments. 
<P>Now I'm going to add one more piece to that - ask yourself those questions at 
least once <I>in the middle of the increment</I>. Ask, "Are we working in a way 
that will work for us? Are our groups and teams set up right - can we even 
deliver this increment working this way?" 
<P>At the first mid-increment introspection, you are mostly interested in 
catching catastrophic errors, things in your process that will stop you from 
succeeding. In later increments, you can make various and sundry improvement and 
optimizations. In one of our projects, during increment 3 we went through 3 team 
structures in 2 months. We had delivered twice, but weren't comfortable with the 
way we were working. So we tried a new team structure, and it became quickly 
obvious that was going to be a total mess. So we changed, and changed again, and 
found a team structure we stayed with for the next 3 increments. We couldn't 
have done that on the first increment, because on the first increment we were 
just focussed on getting something out the door. 
<H3><IMG align=right 
src="Sw Devt as Cooperative Game Talk_files/image54.gif">---------- 6. Crystal 
Methodologies </H3>
<P>Putting all the above thoughts together results in what I call the Crystal 
Manifesto of Software Development, or the Crystal Principle. Software 
development is a cooperative game - using props and markers to remind and 
incite,to reach the next move. The endpoint of the game is a delivered system. 
The next game is to alter or replace the system. The Crystal Principle informs 
us as to how we should play this game to get our software. The notion of the 
Game helps us understand when someone else is playing a different game, and 
gives a handle on how to react. 
<P><IMG align=right src="Sw Devt as Cooperative Game Talk_files/image55.gif">The 
family of methodologies that I am working with fit the gaming model, fit the 
characteristics of humans as nonlinear devices, and fit the grid of 
methodologies. There are a number of Crystal methodologies - I rank them by 
color: Clear, Yellow, Orange, Red, etc., up through Blue and Purple. But all of 
them are based on being strong on communications, light on intermediate work 
products, aiming at high-productivity, and being self-evolving. I am trying to 
build them around the strengths and weaknesses of people, to make them something 
people can live with - habitable is the word. Each one is aimed at being as 
light as possible for the project at hand, to make the most sense in a 
resource-limited, finite, goal-seeking, cooperative, group game. 
<H3><IMG align=right 
src="Sw Devt as Cooperative Game Talk_files/image56.gif">------------ENDING 
</H3>
<P>What is software development, really - and does it matter? The answer to the 
second question is Yes, it matters to you a great deal. If software development 
is really a science, you could apply the scientific method to it. If it is 
really engineering, then you could apply known engineering techniques. If 
software development is a matter of producing models, then you should spend your 
money developing models. 
<P>However, it is none of those. It is a "game", a game of speed and cooperation 
within your team, in competition against other teams. A game against time, and a 
game for mind-share. You should spend your money to win that game. 
<P>Viewing software development as a game gives you better ideas on where to 
spend your money, how to structure your teams, and how they should allocate 
their efforts. 
<P>I hope that in this talk I've managed to not exaggerate or lie, but still 
turn your thoughts in a new direction. Please feel free to visit my website, 
members.aol.com/acockburn, and pull down the draft text and outlines I have 
written on Software as a Cooperative Game, and on the lightest, most people 
tolerant methodology I think can work, Crystal Clear. Thank you. 
</P></BODY></HTML>
